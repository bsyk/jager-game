{"version":3,"sources":["App.js","PlayerInput.js","TimelineRow.js","dinner.png","serviceWorker.js","index.js"],"names":["getLSOrDefault","key","def","lsValue","localStorage","getItem","JSON","parse","e","console","error","setLS","value","setItem","stringify","shuffleInPlace","array","i","length","j","Math","floor","random","App","blankPlayer","name","DEFAULT_SHARE","lastPlayers","lastAllocations","lastGameOptions","slotsPerPlayer","gameLength","perHalf","lastViewOptions","minutes","surprise","hasPlayers","every","p","trim","hasAllocations","hasHash","window","location","hash","showGame","showPlayerInput","useState","playerState","setPlayerState","playerShowState","setPlayerShowState","isDrawn","setDrawn","gameOptions","setGameOptions","viewOptions","setViewOptions","shareMsg","setShareMsg","showMsg","setShowMsg","getViewProperties","preHash","Buffer","from","playerNames","allocationOrder","slotCount","playerCount","Array","reduce","allocs","map","_","makeAllocations","getAllocations","halfTime","halfTimeEntry","start","end","label","type","windowSecs","round","windows","allocations","w","halfTimeAllocation","findIndex","a","before","slice","after","splitBefore","splitAfter","hashAllocations","allocationState","setAllocationState","onUpdatePlayerList","playerList","onRemovePlayer","filter","_x","parseInt","currentTarget","dataset","idx","onPlayerChange","updatedPlayers","target","className","onTimeClick","newViewOptions","src","Dinner","alt","player","onClick","join","htmlFor","id","min","max","onChange","newGameOptions","checked","step","gameHash","toString","mode","open","title","navigator","clipboard","writeText","href","setTimeout","PlayerInput","playerId","data-idx","TimelineRow","reveal","setReveal","hideTimer","asTime","seconds","x","m","s","asMinutes","h","v","padStart","asClock","clearTimeout","isLocalhost","Boolean","hostname","match","registerValidSW","swUrl","config","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","log","onUpdate","onSuccess","catch","ReactDOM","render","document","getElementById","URL","process","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.be353a99.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport { ShuffleOutlined, PeopleOutlined, PersonAddOutlined, DoneOutline, HighlightOffOutlined, MobileScreenShareOutlined } from '@material-ui/icons';\nimport './App.css';\nimport PlayerInput from './PlayerInput';\nimport TimelineRow from './TimelineRow';\nimport Dinner from './dinner.png';\nimport { Tooltip } from '@material-ui/core';\n\nconst getLSOrDefault = (key, def) => {\n  const lsValue = localStorage.getItem(key);\n  if (lsValue) {\n    try {\n      return JSON.parse(lsValue);\n    } catch (e) {\n      console.error(`Can't parse value from localstorage, using default`, e);\n    }\n  }\n  return def;\n};\n\nconst setLS = (key, value) => {\n  localStorage.setItem(key, JSON.stringify(value));\n};\n\nconst shuffleInPlace = array => {\n  for (let i = array.length - 1; i> 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n};\n\nconst makeAllocations = (playerCount, slotsPerPlayer, perHalf) => {\n  if (perHalf) {\n    // Shuffle players separately for each batch of slots, then concat\n    // to ensure that each player has a slot in each round.\n    return [...Array(slotsPerPlayer)].reduce((allocs) => \n      [...allocs, ...shuffleInPlace([...Array(playerCount)].map((_, i) => i % playerCount))]\n    , []);\n  }\n  // Shuffle everything\n  const slotCount = playerCount * slotsPerPlayer;\n  return shuffleInPlace([...Array(slotCount)].map((_, i) => i % playerCount));\n}\n\nfunction App() {\n  const blankPlayer = { name: ''};\n  const DEFAULT_SHARE = 'Click to copy link';\n  const lastPlayers = getLSOrDefault('playerList', [{ ...blankPlayer },{ ...blankPlayer },{ ...blankPlayer }]);\n  const lastAllocations = getLSOrDefault('allocations', []);\n  const lastGameOptions = getLSOrDefault('gameOptions', { slotsPerPlayer: 2, gameLength: 5400, perHalf: false });\n  const lastViewOptions = getLSOrDefault('viewOptions', { minutes: false, surprise: false });\n  const hasPlayers = !!lastPlayers.length && lastPlayers.every(p => !!p.name.trim().length);\n  const hasAllocations = !!lastAllocations.length;\n  const hasHash = !!window.location.hash;\n  const showGame = hasAllocations || hasHash;\n  const showPlayerInput = !hasHash && !hasPlayers;\n\n  const [playerState, setPlayerState] = useState(lastPlayers);\n  const [playerShowState, setPlayerShowState] = useState(showPlayerInput);\n  const [isDrawn, setDrawn] = useState(showGame);\n  const [gameOptions, setGameOptions] = useState(lastGameOptions);\n  const [viewOptions, setViewOptions] = useState(lastViewOptions);\n  const [shareMsg, setShareMsg] = useState(DEFAULT_SHARE);\n  const [showMsg, setShowMsg] = useState(false);\n  \n  const getViewProperties = () => {\n    // Do we have a pre-arranged game to draw?\n    if (window.location.hash) {\n      try {\n        const preHash = window.location.hash;\n        const [gameLength, playerNames, allocationOrder] = JSON.parse(Buffer.from(preHash, 'base64'));\n        const slotCount = allocationOrder.length;\n        return { gameLength, playerNames, allocationOrder, slotCount };\n      } catch (e) {\n        console.error('Error decoding game', e);\n      }\n    }\n\n    // New game\n    // Shuffle and allocate slots\n    // Create array of indexes that we can shuffle\n    const playerCount = playerState.length;\n    const { slotsPerPlayer, gameLength, perHalf } = gameOptions;\n    const slotCount = playerCount * slotsPerPlayer;\n    const allocationOrder = makeAllocations(playerCount, slotsPerPlayer, perHalf);\n    const playerNames = playerState.map(p => p.name);\n    return { gameLength, playerNames, allocationOrder, slotCount };\n  };\n\n  const getAllocations = () => {\n    const { gameLength, playerNames, allocationOrder, slotCount } = getViewProperties();\n    \n    // What size is each window\n    const halfTime = gameLength / 2;\n    const halfTimeEntry = { start: halfTime, end: halfTime, label: 'Half Time', type: 'marker' };\n    const windowSecs = Math.round(gameLength / slotCount);\n    // Make the windows, use allocationOrder as a way to have the same length\n    const windows = allocationOrder.reduce((windows, _, i) => \n      [...windows, { start: i * windowSecs, end: (i + 1) * windowSecs, type: 'allocation' }]\n    , []);\n    // Make sure the last window goes to the end\n    windows[slotCount - 1].end = gameLength;\n    // Allocate a player to each window\n    let allocations = windows.map((w, i) => ({ ...w, label: playerNames[allocationOrder[i]] }));\n    // Split an allocation that crosses half-time\n    const halfTimeAllocation = allocations.findIndex(a => a.start < halfTime && a.end> halfTime);\n    if (~halfTimeAllocation) {\n      const before = allocations.slice(0, halfTimeAllocation);\n      const after = allocations.slice(halfTimeAllocation + 1);\n      const splitBefore = { ...allocations[halfTimeAllocation], end: halfTime, type: 'allocation split' };\n      const splitAfter = { ...allocations[halfTimeAllocation], start: halfTime, type: 'allocation split' };\n      allocations = [...before, splitBefore, halfTimeEntry, splitAfter, ...after];\n    } else {\n      // Insert the halfTime entry\n      allocations = [...allocations.slice(0, allocations.length / 2), halfTimeEntry, ...allocations.slice(allocations.length / 2)];\n    }\n\n    return { allocations, gameLength, allocationOrder };\n  };\n\n  const { allocations: hashAllocations } = hasHash && getAllocations();\n  const [allocationState, setAllocationState] = useState(hashAllocations || lastAllocations);\n  \n  const onUpdatePlayerList = playerList => {\n    setLS('playerList', playerList);\n    setPlayerState(playerList);\n  };\n\n  const onAddPlayer = () => {\n    onUpdatePlayerList([...playerState, { ...blankPlayer }]);\n  };\n\n  const onRemovePlayer = (e) => {\n    onUpdatePlayerList(playerState.filter((_x, i) => i !== parseInt(e.currentTarget.dataset.idx)));\n  };\n\n  const onPlayerChange = (e) => {\n    const updatedPlayers = [...playerState];\n    updatedPlayers[e.target.dataset.idx][e.target.className] = e.target.value;\n    onUpdatePlayerList(updatedPlayers);\n  };\n\n  const onCloseEditPlayers = () => {\n    setPlayerShowState(false);\n  };\n\n  const onEditPlayers = () => {\n    setPlayerShowState(true);\n  };\n\n  const onSlotsChange = (e) => {\n    const newGameOptions = { ...gameOptions, slotsPerPlayer: parseInt(e.target.value) };\n    setLS('gameOptions', newGameOptions);\n    setGameOptions(newGameOptions);\n  };\n\n  const onLengthChange = (e) => {\n    const newGameOptions = { ...gameOptions, gameLength: parseInt(e.target.value) * 60 };\n    setLS('gameOptions', newGameOptions);\n    setGameOptions(newGameOptions);\n  };\n\n  const onPerHalfChange = (e) => {\n    const newGameOptions = { ...gameOptions, perHalf: !!e.target.checked };\n    setLS('gameOptions', newGameOptions);\n    setGameOptions(newGameOptions);\n  };\n\n  const onSurpriseChange = (e) => {\n    const newViewOptions = { ...viewOptions, surprise: !!e.target.checked };\n    setLS('viewOptions', newViewOptions);\n    setViewOptions(newViewOptions);\n  };\n\n  const onTimeClick = () => {\n    const newViewOptions = { ...viewOptions, minutes: !viewOptions.minutes };\n    setLS('viewOptions', newViewOptions);\n    setViewOptions(newViewOptions);\n  };\n\n  const onDraw = () => {\n    setDrawn(true);\n    const { allocations, gameLength, allocationOrder } = getAllocations();\n    setLS('allocations', allocations);\n    setAllocationState(allocations);\n\n    // Create a minimal hash of the game state such that we can share and display it\n    const gameHash = Buffer.from(JSON.stringify([\n      gameLength,\n      playerState.map(p => p.name),\n      allocationOrder,\n    ])).toString('base64');\n    window.location.hash = gameHash;\n  };\n\n  const onReset = () => {\n    window.location.hash = '';\n    const hasPlayers = !!lastPlayers.length && lastPlayers.every(p => !!p.name.trim().length);\n    setPlayerShowState(!hasPlayers);\n    setDrawn(false);\n  };\n  \n  const onShare = () => {\n    if (navigator.clipboard) {\n      navigator.clipboard.writeText(window.location.href);\n      setShareMsg('Copied to clipboard');\n      setShowMsg(true);\n    } else {\n      setShareMsg('Not copied!');\n      setShowMsg(true);\n    }\n    setTimeout(() => {\n      setShowMsg(false);\n      setShareMsg(DEFAULT_SHARE);\n    }, 2000);\n  };\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={Dinner} className=\"App-logo\" alt=\"dinner\" />\n      </header>\n      {\n        playerShowState ? (\n          /**\n           * Edit players mode\n           */\n          <div>\n            <p>\n              Who's playing?\n            </p>\n            {\n              playerState.map((player, idx) => \n                <PlayerInput\n                  key={`player-${idx}`}\n                  idx={idx}\n                  player={player}\n                  onPlayerChange={onPlayerChange}\n                  onRemovePlayer={onRemovePlayer}\n                />)\n            }\n            <div className={'buttonrow'}>\n              <button type=\"button\" onClick={onAddPlayer}><PersonAddOutlined /></button>\n              <button type=\"button\" onClick={onCloseEditPlayers}><DoneOutline /></button>\n            </div>\n          </div>\n        ) : (\n          /**\n           * Game mode\n           */\n          <div>\n            {\n              !isDrawn &&\n              <>\n                <p>\n                  Ready to play?\n                </p>\n                <div>\n                  { playerState.map(player => player.name).join(', ') }\n                </div>\n                <div className={'buttonrow'}>\n                  <label htmlFor=\"slots\">Slots per player: {gameOptions.slotsPerPlayer}</label>\n                  <input type=\"range\" id=\"slots\" min=\"1\" max=\"3\" value={gameOptions.slotsPerPlayer} onChange={onSlotsChange} className={'slider'} />\n                </div>\n                {\n                gameOptions.slotsPerPlayer > 1 && \n                <div className={'controlrow'}>\n                  <label>Slot per round </label>\n                  <label className={\"switch\"}>\n                    <input type=\"checkbox\" checked={gameOptions.perHalf} onChange={onPerHalfChange} />\n                    <span className={\"toggle\"}></span>\n                  </label>\n                </div>\n                }\n                <div className={'controlrow'}>\n                  <label htmlFor=\"len\">Game length (mins) </label>\n                  <input type=\"number\" id=\"len\" min=\"1\" step=\"1\" value={gameOptions.gameLength/60} onChange={onLengthChange} className={'shortnumber'}/>\n                </div>\n                <div className={'controlrow'}>\n                  <label>Surprise mode </label>\n                  <label className={\"switch\"}>\n                    <input type=\"checkbox\" checked={viewOptions.surprise} onChange={onSurpriseChange} />\n                    <span className={\"toggle\"}></span>\n                  </label>\n                </div>\n                <div className={'buttonrow'}>\n                  <button type=\"button\" onClick={onEditPlayers}><PeopleOutlined /></button>\n                  <button type=\"button\" onClick={onDraw}><ShuffleOutlined /></button>\n                </div>\n              </>\n            }\n            { isDrawn &&\n              <>\n                <div className={'timeline'}><ul>\n                  { allocationState.map(({ label, start, end, type }, idx) => \n                      <TimelineRow key={`row-${idx}`} label={label} start={start} end={end} type={type} idx={idx} surprise={viewOptions.surprise} mode={viewOptions.minutes ? 'minutes' : 'clock'} onTimeClick={onTimeClick} />\n                    )\n                  }\n                </ul></div>\n                <div className={'buttonrow'}>\n                  <button type=\"button\" onClick={onReset}><HighlightOffOutlined /></button>\n                  <Tooltip open={showMsg} title={shareMsg}>\n                    <button type=\"button\" onClick={onShare}><MobileScreenShareOutlined /></button>\n                  </Tooltip>\n                </div>\n              </>\n            }\n          </div>\n        )\n      }\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { DeleteOutline } from '@material-ui/icons'\n\nconst PlayerInput = ({ idx, player, onPlayerChange, onRemovePlayer }) => {\n  const playerId = `name-${idx}`;\n  return (\n    <div key={`Player-${idx}`} className={'inputrow'}>\n      <label htmlFor={playerId}>{`Player #${idx + 1}`}</label>\n      <input\n        type=\"text\"\n        name={playerId}\n        data-idx={idx}\n        id={playerId}\n        className=\"name\"\n        value={player.name}\n        onChange={onPlayerChange}\n      />\n      <button type=\"button\" className={'delete'} data-idx={idx} onClick={onRemovePlayer}><DeleteOutline/></button>\n    </div>\n  );\n};\n\nPlayerInput.propTypes = {\n  idx: PropTypes.number,\n  player: PropTypes.object,\n  onPlayerChange: PropTypes.func,\n  onRemoveChange: PropTypes.func,\n};\n\nexport default PlayerInput;","import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\n\nconst asClock = x => {\n  const h = Math.floor(x/(60*60));\n  const m = Math.floor((x-(h*60*60))/60);\n  const s = x - ((h*60*60) + (m*60));\n  const pad = [h, m, s].map(v => (''+v).padStart(2, '0'));\n  return pad.join(':');\n}\n\nconst asMinutes = x => {\n  const m = Math.floor(x/60);\n  const s = x - (m*60);\n  return `${m}m ${s}s`;\n}\n\nconst TimelineRow = ({ idx, label, start, end, type, surprise, mode, onTimeClick }) => {\n\n  const [reveal, setReveal] = useState(!surprise);\n  let hideTimer = null;\n\n  const onReveal = () => {\n    if (surprise) {\n      setReveal(true);\n      if (hideTimer) {\n        clearTimeout(hideTimer);\n        hideTimer = null;\n      }\n      hideTimer = setTimeout(() => setReveal(false), 5000);\n    }\n  };\n\n  const asTime = (seconds) => {\n    return mode === 'minutes' ? asMinutes(seconds) : asClock(seconds);\n  }\n\n  if (type === 'marker') {\n    return (\n      <li key={`marker-${idx}`}>\n        <div className={'markertitle'}>\n          { `${label}` }\n        </div>\n        <div className={'markernumber'}>\n          <span onClick={onTimeClick}>{ `${asTime(start)}` }</span>\n        </div>\n      </li>\n    );\n  }\n  \n  return (\n    <li key={`player-${idx}`} className={`${surprise && reveal ? 'reveal' : ''}`}>\n      <div className={'line'}></div>\n      <div className={'title'} onClick={onReveal}>\n        { `${reveal ? label : 'Tap to reveal'}` }\n      </div>\n      <div className={'number'}>\n        <span onClick={onTimeClick}>{ `${asTime(start)}` }</span>\n        <span onClick={onTimeClick}>{ `${asTime(end)}` }</span>\n      </div>\n    </li>\n  );\n};\n\nTimelineRow.propTypes = {\n  idx: PropTypes.number,\n  label: PropTypes.string,\n  start: PropTypes.number,\n  end: PropTypes.number,\n  type: PropTypes.string,\n  surprise: PropTypes.bool,\n  mode: PropTypes.string,\n};\n\nexport default TimelineRow;","export default __webpack_public_path__ + \"static/media/dinner.029cd2f5.png\";","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}